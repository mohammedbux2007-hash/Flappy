<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy-ish Bird (Graveyard Mode)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #020617;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #wrap {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: #111827;
    }
    #msg {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.35);
      color: #fff;
      font-size: 13px;
      padding: 5px 10px;
      border-radius: 6px;
      z-index: 10;
      pointer-events: none;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div id="msg">Mobile ready • Coins saved • Store → skins</div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resize);
    resize();

    // game states
    let gameState = "home"; // home, playing, gameover, store

    // ratios (responsive)
    const GRAVITY = 0.29;
    const FLAP = -6.5;
    const PIPE_GAP = 0.3;
    const PIPE_WIDTH_RATIO = 0.18;
    const PIPE_INTERVAL = 1650;
    const FLOOR_HEIGHT_RATIO = 0.14;
    const SCROLL_SPEED_RATIO = 0.32;
    const HITBOX_SHRINK = 0.7;

    // theme lerp (day/night)
    let themeLerp = 0;
    let themeTarget = 0;
    const THEME_LERP_SPEED = 0.08;

    // coins
    let coins = [];
    const COIN_SPAWN_CHANCE = 0.5;
    let totalCoins = 0;

    // particles
    let particles = [];

    // characters (added Skeleton)
    const CHARACTERS = [
      { id: "default",  name: "Sunny Bird",   price: 0,   owned: true },
      { id: "red",      name: "Red Blaze",    price: 20,  owned: false },
      { id: "shadow",   name: "Shadow Wing",  price: 50,  owned: false },
      { id: "skeleton", name: "Skeleton Bird",price: 100, owned: false },
    ];
    let ownedChars = new Set(["default"]);
    let selectedChar = "default";

    // load persistent
    try {
      const savedCoins = localStorage.getItem("flappyCoins");
      if (savedCoins !== null) totalCoins = parseInt(savedCoins, 10) || 0;

      const savedOwned = localStorage.getItem("flappyOwnedChars");
      if (savedOwned) ownedChars = new Set(JSON.parse(savedOwned));

      const savedSelected = localStorage.getItem("flappySelectedChar");
      if (savedSelected) selectedChar = savedSelected;
    } catch(e){}

    // sync flags
    for (let c of CHARACTERS) {
      if (ownedChars.has(c.id)) c.owned = true;
    }

    // runtime vars
    let bird, pipes, lastPipeTime, score = 0, best = 0, bgClouds, groundOffset = 0;

    function getSize() {
      return { W: canvas.clientWidth, H: canvas.clientHeight };
    }

    function resetGame(full=true) {
      const {W,H} = getSize();
      bird = {
        x: W * 0.22,
        y: H * 0.5,
        vy: 0,
        r: Math.min(W, H) * 0.045,
        anim: 0
      };
      pipes = [];
      coins = [];
      particles = [];
      lastPipeTime = performance.now();
      score = 0;
      groundOffset = 0;
      initClouds();
      themeTarget = 0;
      themeLerp = 0;
      if (full) gameState = "home";
    }

    function isGraveyardMode() {
      return selectedChar === "skeleton";
    }

    function getThemeTargetFromScore(sc) {
      if (isGraveyardMode()) return 1; // force dark for skeleton
      return Math.floor(sc / 5) % 2;
    }

    function initClouds() {
      const {W,H} = getSize();
      bgClouds = [];
      for (let i = 0; i < 5; i++) {
        bgClouds.push({
          x: Math.random() * W,
          y: Math.random() * (H * 0.35) + H * 0.02,
          w: Math.random() * (W * 0.14) + (W * 0.1),
          h: Math.random() * (H * 0.025) + (H * 0.02),
          s: Math.random() * 0.45 + 0.15
        });
      }
    }

    function spawnPipe() {
      const {W,H} = getSize();
      const floorH = H * FLOOR_HEIGHT_RATIO;
      const gapPx = H * PIPE_GAP;
      const pipeW = W * PIPE_WIDTH_RATIO;
      const maxTop = H - floorH - gapPx - (H * 0.12);
      const minTop = H * 0.07;
      const topHeight = Math.floor(Math.random() * (maxTop - minTop) + minTop);

      pipes.push({
        x: W,
        top: topHeight,
        passed: false
      });

      if (Math.random() < COIN_SPAWN_CHANCE) {
        const gapCenter = topHeight + gapPx / 2;
        coins.push({
          x: W + pipeW / 2,
          y: gapCenter,
          r: Math.min(W,H) * 0.028,
          t: Math.random() * Math.PI * 2,
          collected: false,
          glow: 1
        });
      }
    }

    function startPlaying() { gameState = "playing"; bird.vy = 0; }
    function goToStore()   { gameState = "store"; }

    function flap() {
      if (gameState === "home") { startPlaying(); return; }
      if (gameState === "store") return;
      if (gameState === "gameover") { resetGame(true); return; }
      bird.vy = FLAP;
    }

    canvas.addEventListener("mousedown", pointer);
    canvas.addEventListener("touchstart", e => { e.preventDefault(); pointer(e.touches[0]); }, {passive:false});

    function pointer(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const {W,H} = getSize();

      if (gameState === "home") {
        const playBtn  = getPlayBtn(W,H);
        const storeBtn = getStoreBtn(W,H);
        if (inRect(mx,my,playBtn))  { startPlaying(); return; }
        if (inRect(mx,my,storeBtn)) { goToStore(); return; }
        flap();
        return;
      }
      if (gameState === "store") {
        handleStoreClick(mx,my);
        return;
      }
      if (gameState === "gameover") {
        resetGame(true);
        return;
      }
      flap();
    }

    document.addEventListener("keydown", e => {
      if (e.code === "Space" || e.code === "ArrowUp") flap();
      if (e.code === "Escape" && gameState === "store") gameState = "home";
    });

    function inRect(x,y,r) {
      return x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h;
    }

    function handleStoreClick(mx,my) {
      const {W,H} = getSize();
      const backBtn = { x: W*0.05, y: H*0.04, w: W*0.2, h: H*0.055 };
      if (inRect(mx,my,backBtn)) { gameState = "home"; return; }

      // cards
      const startX = W*0.07;
      const startY = H*0.18;
      const cardW  = W*0.38;
      const cardH  = H*0.22;
      const gapX   = W*0.04;
      for (let i = 0; i < CHARACTERS.length; i++) {
        const ch = CHARACTERS[i];
        const col = i % 2;
        const row = Math.floor(i / 2);
        const cx = startX + col * (cardW + gapX);
        const cy = startY + row * (cardH + H*0.025);
        if (inRect(mx,my,{x:cx,y:cy,w:cardW,h:cardH})) {
          selectOrBuy(ch);
          return;
        }
      }
    }

    function selectOrBuy(ch) {
      if (ownedChars.has(ch.id)) {
        selectedChar = ch.id;
        saveState();
        return;
      }
      if (totalCoins >= ch.price) {
        totalCoins -= ch.price;
        ownedChars.add(ch.id);
        ch.owned = true;
        selectedChar = ch.id;
        saveState();
      }
    }

    function saveState() {
      try {
        localStorage.setItem("flappyCoins", totalCoins.toString());
        localStorage.setItem("flappyOwnedChars", JSON.stringify(Array.from(ownedChars)));
        localStorage.setItem("flappySelectedChar", selectedChar);
      } catch(e){}
    }

    function update(dt, now) {
      themeTarget = getThemeTargetFromScore(score);
      themeLerp += (themeTarget - themeLerp) * THEME_LERP_SPEED;

      // particles
      for (let p of particles) {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.04;
        p.vy += 0.02;
      }
      particles = particles.filter(p => p.life > 0);

      if (gameState !== "playing") {
        moveClouds(dt);
        // float idle bird
        if (gameState === "home" || gameState === "store") {
          const {H} = getSize();
          bird.y = H*0.48 + Math.sin(now * 0.004) * 8;
        }
        return;
      }

      // playing
      bird.vy += GRAVITY;
      bird.y  += bird.vy;
      bird.anim += dt * 0.01;

      const {W,H} = getSize();
      const floorH = H * FLOOR_HEIGHT_RATIO;
      const gapPx = H * PIPE_GAP;
      const pipeW = W * PIPE_WIDTH_RATIO;
      const scrollPx = (SCROLL_SPEED_RATIO * W) * (dt / 1000);

      if (now - lastPipeTime > PIPE_INTERVAL) {
        spawnPipe();
        lastPipeTime = now;
      }

      for (let p of pipes) p.x -= scrollPx;
      pipes = pipes.filter(p => p.x + pipeW > -10);

      for (let c of coins) {
        c.x -= scrollPx;
        c.t += dt * 0.008;
      }
      coins = coins.filter(c => !c.collected && c.x + c.r > -10);

      moveClouds(dt);
      groundOffset -= scrollPx;
      if (groundOffset <= -(W*0.25)) groundOffset = 0;

      const bx = bird.x;
      const by = bird.y;
      const hitR = bird.r * HITBOX_SHRINK;

      // coin collision
      for (let c of coins) {
        const dx = bx - c.x;
        const dy = by - c.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < hitR + c.r * 0.85) {
          c.collected = true;
          totalCoins += 1;
          spawnCoinBurst(c.x, c.y);
          saveState();
        }
      }

      // pipe collision & score
      for (let p of pipes) {
        const inX = bx + hitR > p.x && bx - hitR < p.x + pipeW;
        const gapTop = p.top;
        const gapBottom = p.top + gapPx;
        if (inX) {
          if (by - hitR < gapTop || by + hitR > gapBottom) {
            die();
          }
        }
        if (!p.passed && p.x + pipeW < bx) {
          p.passed = true;
          score++;
          if (score > best) best = score;
        }
      }

      // ground/top
      if (by + hitR > H - floorH || by - hitR < 0) {
        die();
      }
    }

    function spawnCoinBurst(x,y) {
      for (let i = 0; i < 6; i++) {
        particles.push({
          x,y,
          vx: (Math.random()-0.5)*2,
          vy: (Math.random()-1.4)*2,
          life: 1,
          c: i%2===0 ? "rgba(255,220,120,1)" : "rgba(255,180,60,1)"
        });
      }
    }

    function moveClouds(dt) {
      const {W} = getSize();
      for (let c of bgClouds) {
        c.x -= c.s;
        if (c.x + c.w < -10) {
          c.x = W + 30;
        }
      }
    }

    function die() {
      gameState = "gameover";
    }

    function lerpColor(c1,c2,t) {
      return [
        c1[0] + (c2[0]-c1[0])*t,
        c1[1] + (c2[1]-c1[1])*t,
        c1[2] + (c2[2]-c1[2])*t,
      ];
    }

    // ===== DRAW =====
    function drawBackground() {
      const {W,H} = getSize();

      if (isGraveyardMode()) {
        // graveyard sky
        const grad = ctx.createLinearGradient(0,0,0,H);
        grad.addColorStop(0, "#0f172a");
        grad.addColorStop(0.5, "#111827");
        grad.addColorStop(1, "#020617");
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,W,H);

        // big moon
        ctx.fillStyle = "rgba(248,250,252,0.9)";
        ctx.beginPath();
        ctx.arc(W*0.16, H*0.14, H*0.06, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "rgba(2,6,23,0.45)";
        ctx.beginPath();
        ctx.arc(W*0.19, H*0.12, H*0.055, 0, Math.PI*2);
        ctx.fill();

        // mist layers
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = `rgba(15,23,42,${0.12 - i*0.03})`;
          ctx.beginPath();
          ctx.roundRect(-30, H*0.6 + i*14, W+60, H*0.12, 25);
          ctx.fill();
        }

      } else {
        // normal day/night blend
        const dayTop = [126, 208, 255];
        const dayMid = [201, 239, 255];
        const dayBot = [253, 240, 213];
        const nightTop = [7, 25, 40];
        const nightMid = [13, 48, 71];
        const nightBot = [32, 44, 58];
        const top = lerpColor(dayTop, nightTop, themeLerp);
        const mid = lerpColor(dayMid, nightMid, themeLerp);
        const bot = lerpColor(dayBot, nightBot, themeLerp);
        const grad = ctx.createLinearGradient(0,0,0,H);
        grad.addColorStop(0, `rgb(${top[0]},${top[1]},${top[2]})`);
        grad.addColorStop(0.6, `rgb(${mid[0]},${mid[1]},${mid[2]})`);
        grad.addColorStop(1, `rgb(${bot[0]},${bot[1]},${bot[2]})`);
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,W,H);

        // stars only at night
        const starAlpha = themeLerp * 0.9;
        if (starAlpha > 0.02) {
          ctx.fillStyle = `rgba(255,255,255,${starAlpha})`;
          for (let i = 0; i < 25; i++) {
            const x = (i * 14 + (score*3)) % W;
            const y = (i * 19) % (H * 0.32);
            ctx.fillRect(x, y, 2, 2);
          }
          ctx.fillStyle = `rgba(255,255,255,${0.8*themeLerp})`;
          ctx.beginPath();
          ctx.arc(W*0.15, H*0.12, H*0.04, 0, Math.PI*2);
          ctx.fill();
        }
      }

      // clouds (works for both)
      for (let c of bgClouds) {
        let cloudAlpha = isGraveyardMode() ? 0.28 : (0.9 - 0.7*themeLerp);
        ctx.fillStyle = `rgba(255,255,255,${cloudAlpha})`;
        ctx.beginPath();
        ctx.roundRect(c.x, c.y, c.w, c.h, 12);
        ctx.fill();
      }
    }

    function drawPipes() {
      const {W,H} = getSize();
      const pipeW = W * PIPE_WIDTH_RATIO;
      const floorH = H * FLOOR_HEIGHT_RATIO;
      const gapPx = H * PIPE_GAP;

      for (let p of pipes) {
        if (isGraveyardMode()) {
          // tombstone pillars
          const bottomH = H - floorH - (p.top + gapPx);
          const tombColor = "#1f2937";
          const tombStroke = "rgba(248,250,252,0.06)";

          // top stone
          ctx.fillStyle = tombColor;
          ctx.beginPath();
          ctx.roundRect(p.x, 0, pipeW, p.top, 12);
          ctx.fill();
          ctx.strokeStyle = tombStroke;
          ctx.strokeRect(p.x, 0, pipeW, p.top);

          // bottom stone
          ctx.fillStyle = tombColor;
          ctx.beginPath();
          ctx.roundRect(p.x, p.top + gapPx, pipeW, bottomH, 12);
          ctx.fill();
          ctx.strokeStyle = tombStroke;
          ctx.strokeRect(p.x, p.top + gapPx, pipeW, bottomH);

          // cross engrave
          ctx.strokeStyle = "rgba(248,250,252,0.3)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x + pipeW/2, (p.top)*0.35);
          ctx.lineTo(p.x + pipeW/2, (p.top)*0.7);
          ctx.moveTo(p.x + pipeW/2 - 8, (p.top)*0.5);
          ctx.lineTo(p.x + pipeW/2 + 8, (p.top)*0.5);
          ctx.stroke();

        } else {
          // normal pipes
          const c1 = lerpColor([46,159,69],[43,58,85], themeLerp);
          const c2 = lerpColor([62,207,91],[61,83,116], themeLerp);
          const c3 = lerpColor([43,127,59],[31,40,55], themeLerp);
          const grad = ctx.createLinearGradient(p.x, 0, p.x + pipeW, 0);
          grad.addColorStop(0, `rgb(${c1[0]},${c1[1]},${c1[2]})`);
          grad.addColorStop(0.5, `rgb(${c2[0]},${c2[1]},${c2[2]})`);
          grad.addColorStop(1, `rgb(${c3[0]},${c3[1]},${c3[2]})`);
          ctx.fillStyle = grad;

          ctx.fillRect(p.x, 0, pipeW, p.top);
          const lipColor = `rgba(${Math.floor(217 - 60*themeLerp)},${Math.floor(255 - 60*themeLerp)},${Math.floor(212 - 60*themeLerp)},${1 - 0.4*themeLerp})`;
          ctx.fillStyle = lipColor;
          ctx.fillRect(p.x - 3, p.top - (H*0.03), pipeW + 6, H*0.03);

          const bottomH = H - floorH - (p.top + gapPx);
          ctx.fillStyle = grad;
          ctx.fillRect(p.x, p.top + gapPx, pipeW, bottomH);
          ctx.fillStyle = lipColor;
          ctx.fillRect(p.x - 3, p.top + gapPx, pipeW + 6, H*0.03);
        }
      }
    }

    function drawGround() {
      const {W,H} = getSize();
      const floorH = H * FLOOR_HEIGHT_RATIO;
      if (isGraveyardMode()) {
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(0, H - floorH, W, floorH);
        ctx.fillStyle = "rgba(17,24,39,0.6)";
        ctx.fillRect(0, H - floorH, W, H*0.02);
        // tombstones foreground
        ctx.fillStyle = "rgba(15,23,42,0.35)";
        for (let i = 0; i < 5; i++) {
          const tw = W*0.1;
          const x = (i*W*0.2 + groundOffset*0.5) % (W+tw) - tw;
          ctx.beginPath();
          ctx.roundRect(x, H - floorH + H*0.03, tw, H*0.1, 10);
          ctx.fill();
        }
      } else {
        const groundCol = lerpColor([212,170,99],[47,43,50], themeLerp);
        ctx.fillStyle = `rgb(${groundCol[0]},${groundCol[1]},${groundCol[2]})`;
        ctx.fillRect(0, H - floorH, W, floorH);

        const grassCol = lerpColor([99,184,64],[63,95,72], themeLerp);
        ctx.fillStyle = `rgb(${grassCol[0]},${grassCol[1]},${grassCol[2]})`;
        ctx.fillRect(0, H - floorH, W, H*0.025);

        const tileW = W * 0.2;
        const patternAlpha = 0.1 - 0.06 * themeLerp;
        ctx.fillStyle = `rgba(0,0,0,${Math.max(patternAlpha,0)})`;
        for (let x = groundOffset; x < W + tileW; x += tileW) {
          ctx.fillRect(x, H - floorH + H*0.03, tileW*0.65, H*0.025);
        }
      }
    }

    function drawBird() {
      const {W,H} = getSize();
      ctx.save();
      ctx.translate(bird.x, bird.y);
      const tilt = (gameState === "home" || gameState === "store")
        ? Math.sin(performance.now() * 0.004) * 0.15
        : Math.min(Math.max(bird.vy / 10, -0.45), 0.6);
      ctx.rotate(tilt);

      let base1, base2, wingCol, cheekCol, beakCol, eyeCol="#fff", pupil="#000";
      if (selectedChar === "default") {
        base1 = lerpColor([255,217,102],[255,226,168], themeLerp);
        base2 = lerpColor([255,174,0],[255,193,78], themeLerp);
        wingCol = lerpColor([255,233,168],[255,244,216], themeLerp);
        cheekCol = lerpColor([255,120,120],[255,196,196], themeLerp);
        beakCol = lerpColor([255,123,26],[255,156,70], themeLerp);
      } else if (selectedChar === "red") {
        base1 = [255,120,120];
        base2 = [232,46,46];
        wingCol = [255,214,214];
        cheekCol = [255,210,210];
        beakCol = [255,131,60];
      } else if (selectedChar === "shadow") {
        base1 = [187,210,255];
        base2 = [60,73,108];
        wingCol = [207,219,255];
        cheekCol = [142,162,206];
        beakCol = [255,206,116];
      } else {
        // skeleton bird
        base1 = [226,232,240];
        base2 = [148,163,184];
        wingCol = [203,213,225];
        cheekCol = [203,213,225];
        beakCol = [248,250,252];
        eyeCol = "#e11d48"; // red eye
        pupil = "#fda4af";
      }

      const bodyWidth = W*0.055;
      const bodyHeight = H*0.04;
      const grd = ctx.createLinearGradient(-12, -16, 24, 16);
      grd.addColorStop(0, `rgb(${base1[0]},${base1[1]},${base1[2]})`);
      grd.addColorStop(1, `rgb(${base2[0]},${base2[1]},${base2[2]})`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(0, 0, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
      ctx.fill();

      const wingOffset = Math.sin(bird.anim * 8) * 4;
      ctx.save();
      ctx.translate(-W*0.017, H*0.007 + wingOffset * 0.2);
      ctx.fillStyle = `rgb(${wingCol[0]},${wingCol[1]},${wingCol[2]})`;
      ctx.beginPath();
      ctx.roundRect(-W*0.03, -H*0.015, W*0.06, H*0.03, 8);
      ctx.fill();
      ctx.restore();

      // eye
      ctx.fillStyle = eyeCol;
      ctx.beginPath();
      ctx.arc(W*0.025, -H*0.012, H*0.012, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = pupil;
      ctx.beginPath();
      ctx.arc(W*0.03, -H*0.012, H*0.005, 0, Math.PI*2);
      ctx.fill();

      // skull cracks (tiny)
      if (selectedChar === "skeleton") {
        ctx.strokeStyle = "rgba(15,23,42,0.7)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-W*0.01, -H*0.012);
        ctx.lineTo(-W*0.02, -H*0.02);
        ctx.lineTo(-W*0.03, -H*0.01);
        ctx.stroke();
      }

      // cheek (light)
      ctx.fillStyle = `rgba(${cheekCol[0]},${cheekCol[1]},${cheekCol[2]},0.6)`;
      ctx.beginPath();
      ctx.arc(-W*0.01, H*0.009, H*0.007, 0, Math.PI*2);
      ctx.fill();

      // beak
      ctx.fillStyle = `rgb(${beakCol[0]},${beakCol[1]},${beakCol[2]})`;
      ctx.beginPath();
      ctx.moveTo(W*0.045, -H*0.003);
      ctx.lineTo(W*0.07, H*0.01);
      ctx.lineTo(W*0.045, H*0.02);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawCoins() {
      for (let c of coins) {
        const glowRadius = c.r * 2;
        ctx.save();
        ctx.globalAlpha = 0.4 + 0.2 * Math.sin(c.t * 2);
        const grad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, glowRadius);
        grad.addColorStop(0, "rgba(255,220,120,1)");
        grad.addColorStop(1, "rgba(255,220,120,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, glowRadius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        const spin = (Math.sin(c.t * 3) * 0.3) + 1;
        const rX = c.r * spin;
        const rY = c.r;
        const coinGrad = ctx.createRadialGradient(c.x - 3, c.y - 4, 2, c.x, c.y, rY + 2);
        coinGrad.addColorStop(0, "#fff9d6");
        coinGrad.addColorStop(0.4, "#ffd447");
        coinGrad.addColorStop(1, "#c97a1a");
        ctx.fillStyle = coinGrad;
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, rX, rY, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = "rgba(255,216,140,0.9)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, rX-2, rY-2, 0, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    function drawParticles() {
      for (let p of particles) {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.c;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function getPlayBtn(W,H) {
      // centered buttons
      const btnW = Math.min(W*0.45, 220);
      const btnH = Math.min(H*0.09, 58);
      return { x: (W - btnW)/2, y: H*0.54, w: btnW, h: btnH };
    }
    function getStoreBtn(W,H) {
      const btnW = Math.min(W*0.45, 220);
      const btnH = Math.min(H*0.09, 58);
      return { x: (W - btnW)/2, y: H*0.54 + btnH + H*0.018, w: btnW, h: btnH };
    }

    function drawHomeScreen() {
      const {W,H} = getSize();
      // blurred panel
      ctx.fillStyle = "rgba(3, 7, 18, 0.35)";
      ctx.beginPath();
      ctx.roundRect(W*0.08, H*0.15, W*0.84, H*0.58, 18);
      ctx.fill();

      // title
      ctx.fillStyle = "#fff";
      ctx.font = "600 " + (H*0.045).toFixed(0) + "px system-ui";
      ctx.fillText("Flappy-ish", W*0.24, H*0.23);

      // subtitle (brief!)
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.font = (H*0.021).toFixed(0) + "px system-ui";
      ctx.fillText("Collect coins. Unlock skins.", W*0.23, H*0.27);

      // current coins
      drawCoinHudSmall(W*0.5, H*0.32, totalCoins);

      // buttons
      const playBtn = getPlayBtn(W,H);
      drawPrimaryButton(playBtn.x, playBtn.y, playBtn.w, playBtn.h, "Play");

      const storeBtn = getStoreBtn(W,H);
      drawStoreButton(storeBtn.x, storeBtn.y, storeBtn.w, storeBtn.h);

      // best
      ctx.fillStyle = "rgba(255,255,255,0.6)";
      ctx.font = (H*0.018).toFixed(0) + "px system-ui";
      ctx.fillText("Best: " + best, W*0.42, storeBtn.y + storeBtn.h + H*0.04);
    }

    function drawPrimaryButton(x,y,w,h,label) {
      const grad = ctx.createLinearGradient(x,y,x+w,y+h);
      grad.addColorStop(0, "#38bdf8");
      grad.addColorStop(1, "#0ea5e9");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.roundRect(x,y,w,h,14);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "600 " + (h*0.38).toFixed(0) + "px system-ui";
      const tw = ctx.measureText(label).width;
      ctx.fillText(label, x + (w - tw)/2, y + h*0.65);
    }

    function drawStoreButton(x,y,w,h) {
      const grad = ctx.createLinearGradient(x,y,x+w,y+h);
      grad.addColorStop(0, "#f97316");
      grad.addColorStop(1, "#ea580c");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.roundRect(x,y,w,h,14);
      ctx.fill();

      // cart icon
      const iconSize = h*0.45;
      drawCartIcon(x + h*0.25, y + h*0.25, iconSize, iconSize);

      ctx.fillStyle = "#fff";
      ctx.font = "600 " + (h*0.35).toFixed(0) + "px system-ui";
      ctx.fillText("Store", x + h*0.75, y + h*0.65);
    }

    function drawCartIcon(x,y,w,h) {
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.9)";
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + w*0.1, y + h);
      ctx.lineTo(x + w, y + h);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x + w*0.15, y + h*0.15);
      ctx.lineTo(x + w, y + h*0.15);
      ctx.lineTo(x + w*0.85, y + h*0.7);
      ctx.lineTo(x + w*0.2, y + h*0.7);
      ctx.closePath();
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(x + w*0.25, y + h*1.05, h*0.14, 0, Math.PI*2);
      ctx.arc(x + w*0.8, y + h*1.05, h*0.14, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fill();
      ctx.restore();
    }

    function drawCoinHudSmall(x, y, value) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      const g = ctx.createRadialGradient(x, y, 0, x, y, 16);
      g.addColorStop(0, "rgba(255,214,120,1)");
      g.addColorStop(1, "rgba(255,214,120,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x, y, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      const r = 10;
      const grad = ctx.createRadialGradient(x - 2, y - 3, 2, x, y, r);
      grad.addColorStop(0, "#fff6d1");
      grad.addColorStop(0.5, "#ffd447");
      grad.addColorStop(1, "#d88b1a");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.7)";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = "#fff";
      ctx.font = "12px system-ui";
      ctx.fillText("x " + value, x + 16, y + 4);
    }

    function drawStoreScreen() {
      const {W,H} = getSize();
      ctx.fillStyle = "rgba(2,6,23,0.65)";
      ctx.beginPath();
      ctx.roundRect(W*0.04, H*0.04, W*0.92, H*0.9, 18);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "600 " + (H*0.03).toFixed(0) + "px system-ui";
      ctx.fillText("Store", W*0.07, H*0.085);

      drawCoinHudSmall(W*0.87, H*0.085, totalCoins);

      // back
      ctx.fillStyle = "rgba(15,118,178,0.85)";
      ctx.beginPath();
      ctx.roundRect(W*0.05, H*0.04, W*0.2, H*0.055, 10);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = (H*0.02).toFixed(0) + "px system-ui";
      ctx.fillText("← Home", W*0.08, H*0.08);

      // cards
      const startX = W*0.07;
      const startY = H*0.18;
      const cardW  = W*0.38;
      const cardH  = H*0.22;
      const gapX   = W*0.04;
      for (let i = 0; i < CHARACTERS.length; i++) {
        const ch = CHARACTERS[i];
        const col = i % 2;
        const row = Math.floor(i / 2);
        const cx = startX + col * (cardW + gapX);
        const cy = startY + row * (cardH + H*0.025);

        ctx.fillStyle = "rgba(255,255,255,0.02)";
        ctx.beginPath();
        ctx.roundRect(cx, cy, cardW, cardH, 14);
        ctx.fill();
        ctx.strokeStyle = ch.id === selectedChar ? "rgba(56,189,248,0.8)" : "rgba(255,255,255,0.04)";
        ctx.lineWidth = ch.id === selectedChar ? 2 : 1;
        ctx.strokeRect(cx, cy, cardW, cardH);

        // preview
        drawCharacterPreview(ch, cx + cardW/2, cy + H*0.065);

        // name
        ctx.fillStyle = "#fff";
        ctx.font = (H*0.018).toFixed(0) + "px system-ui";
        const nameW = ctx.measureText(ch.name).width;
        ctx.fillText(ch.name, cx + (cardW - nameW)/2, cy + H*0.13);

        if (ch.owned) {
          ctx.fillStyle = "rgba(34,197,94,0.85)";
          ctx.font = (H*0.015).toFixed(0) + "px system-ui";
          ctx.fillText("Owned", cx + cardW*0.35, cy + H*0.16);
        } else {
          drawCoinHudSmall(cx + W*0.085, cy + H*0.16, ch.price);
        }

        if (ch.id === selectedChar) {
          ctx.fillStyle = "rgba(56,189,248,0.75)";
          ctx.beginPath();
          ctx.roundRect(cx + cardW*0.26, cy + cardH - H*0.045, cardW*0.3, H*0.025, 8);
          ctx.fill();
          ctx.fillStyle = "#fff";
          ctx.font = (H*0.014).toFixed(0) + "px system-ui";
          ctx.fillText("Selected", cx + cardW*0.32, cy + cardH - H*0.025);
        }
      }
    }

    function drawCharacterPreview(ch, x, y) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(0.85, 0.85);

      let base1, base2, wingCol, cheekCol, beakCol, eye="#fff", pupil="#000";
      if (ch.id === "default") {
        base1 = [255,217,102]; base2 = [255,174,0];
        wingCol = [255,233,168]; cheekCol = [255,120,120]; beakCol = [255,123,26];
      } else if (ch.id === "red") {
        base1 = [255,120,120]; base2 = [232,46,46];
        wingCol = [255,214,214]; cheekCol = [255,210,210]; beakCol = [255,131,60];
      } else if (ch.id === "shadow") {
        base1 = [187,210,255]; base2 = [60,73,108];
        wingCol = [207,219,255]; cheekCol = [142,162,206]; beakCol = [255,206,116];
      } else {
        base1 = [226,232,240]; base2 = [148,163,184];
        wingCol = [203,213,225]; cheekCol = [203,213,225]; beakCol = [248,250,252];
        eye = "#e11d48"; pupil = "#fda4af";
      }

      const grd = ctx.createLinearGradient(-12, -16, 24, 16);
      grd.addColorStop(0, `rgb(${base1[0]},${base1[1]},${base1[2]})`);
      grd.addColorStop(1, `rgb(${base2[0]},${base2[1]},${base2[2]})`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(0, 0, 20, 16, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = `rgb(${wingCol[0]},${wingCol[1]},${wingCol[2]})`;
      ctx.beginPath();
      ctx.roundRect(-10, 0, 20, 10, 6);
      ctx.fill();

      ctx.fillStyle = eye;
      ctx.beginPath();
      ctx.arc(9, -6, 4.5, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = pupil;
      ctx.beginPath();
      ctx.arc(11, -6, 2, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = `rgb(${cheekCol[0]},${cheekCol[1]},${cheekCol[2]})`;
      ctx.beginPath();
      ctx.arc(-3, 4, 3, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = `rgb(${beakCol[0]},${beakCol[1]},${beakCol[2]})`;
      ctx.beginPath();
      ctx.moveTo(18, -2);
      ctx.lineTo(30, 2);
      ctx.lineTo(18, 6);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawHUD() {
      const {W,H} = getSize();
      ctx.fillStyle = "rgba(3,7,18,0.3)";
      ctx.beginPath();
      ctx.roundRect(W*0.03, H*0.02, W*0.58, H*0.085, 12);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "bold " + (H*0.038).toFixed(0) + "px system-ui";
      ctx.fillText(score.toString(), W*0.045, H*0.075);

      ctx.fillStyle = "rgba(255,255,255,0.6)";
      ctx.font = (H*0.018).toFixed(0) + "px system-ui";
      ctx.fillText("Best: " + best, W*0.045, H*0.1);

      drawCoinHudSmall(W - 90, 30, totalCoins);
    }

    function drawGameOver() {
      const {W,H} = getSize();
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);
      const cardW = W*0.7, cardH = H*0.35;
      const cx = (W-cardW)/2, cy = (H-cardH)/2;
      ctx.fillStyle = "rgba(255,255,255,0.96)";
      ctx.beginPath();
      ctx.roundRect(cx, cy, cardW, cardH, 14);
      ctx.fill();

      ctx.fillStyle = "#0f172a";
      ctx.font = "600 " + (H*0.03).toFixed(0) + "px system-ui";
      ctx.fillText("Game Over", cx + W*0.14, cy + H*0.045);

      ctx.fillStyle = "#334155";
      ctx.font = (H*0.02).toFixed(0) + "px system-ui";
      ctx.fillText("Score: " + score, cx + W*0.05, cy + H*0.095);
      ctx.fillText("Best: " + best, cx + W*0.05, cy + H*0.13);
      ctx.fillText("Coins: " + totalCoins, cx + W*0.05, cy + H*0.165);

      // button
      const bw = cardW - W*0.12, bh = H*0.06;
      const bx = cx + W*0.06, by = cy + H*0.21;
      const grad = ctx.createLinearGradient(bx,by,bx+bw,by+bh);
      grad.addColorStop(0, "#38bdf8");
      grad.addColorStop(1, "#0ea5e9");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.roundRect(bx,by,bw,bh,10);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = (H*0.02).toFixed(0) + "px system-ui";
      ctx.fillText("Back to home", bx + W*0.06, by + H*0.042);
    }

    // main loop
    let last = performance.now();
    function loop(now) {
      const dt = now - last;
      last = now;
      update(dt, now);

      const {W,H} = getSize();
      ctx.clearRect(0,0,W,H);

      drawBackground();
      drawPipes();
      drawGround();
      drawCoins();
      drawParticles();
      drawBird();

      if (gameState === "home")      drawHomeScreen();
      else if (gameState === "playing") { drawHUD(); }
      else if (gameState === "gameover") { drawHUD(); drawGameOver(); }
      else if (gameState === "store") { drawStoreScreen(); }

      requestAnimationFrame(loop);
    }

    resetGame(true);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
