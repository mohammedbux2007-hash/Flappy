<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Clean</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #020617;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: manipulation;
    }
    #gameWrap {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: 480px;
      max-height: 900px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      display: block;
      background: #7ed0ff;
      border-radius: 18px;
      box-shadow: 0 20px 45px rgba(0,0,0,0.35);
      image-rendering: optimizeSpeed;
      image-rendering: -webkit-optimize-contrast;
    }
    .top-ui {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    .btn {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      background: rgba(0,0,0,0.38);
      border: 1px solid rgba(255,255,255,0.12);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      backdrop-filter: blur(4px);
      touch-action: manipulation;
      user-select: none;
    }
    .btn:active {
      transform: scale(0.94);
    }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game"></canvas>
    <div class="top-ui">
      <div class="btn" id="pauseBtn" title="Pause">II</div>
      <div class="btn" id="muteBtn" title="Mute">ðŸ”Š</div>
    </div>
  </div>

  <script>
    const BASE_W = 360;
    const BASE_H = 540;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    canvas.width = BASE_W;
    canvas.height = BASE_H;

    function fitCanvas() {
      const wrap = document.getElementById("gameWrap");
      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      const scale = Math.min(w / BASE_W, h / BASE_H);
      canvas.style.width = BASE_W * scale + "px";
      canvas.style.height = BASE_H * scale + "px";
    }
    window.addEventListener("resize", fitCanvas);
    fitCanvas();

    let gameState = "home";

    const GRAVITY = 0.29;
    const FLAP = -6.5;
    const PIPE_GAP = 160;
    const PIPE_WIDTH = 64;
    const PIPE_INTERVAL = 1550;
    const FLOOR_HEIGHT = 76;
    const SCROLL_SPEED = 1.8;
    const HITBOX_SHRINK = 0.7;

    let themeLerp = 0;
    let themeTarget = 0;
    const THEME_LERP_SPEED = 0.08;

    let bird, pipes, lastPipeTime, score, best, bgClouds, groundOffset;
    best = 0;
    let coins = [];
    let totalCoins = 0;
    let particles = [];

    // audio
    let audioCtx = null;
    let musicGain = null;
    let musicStarted = false;
    let muted = false;

    const pauseBtn = document.getElementById("pauseBtn");
    const muteBtn = document.getElementById("muteBtn");

    try {
      const savedCoins = localStorage.getItem("flappyCoins");
      if (savedCoins !== null) totalCoins = parseInt(savedCoins, 10) || 0;
      const savedBest = localStorage.getItem("flappyBest");
      if (savedBest !== null) best = parseInt(savedBest, 10) || 0;
    } catch(e) {}

    function initClouds() {
      bgClouds = [];
      for (let i = 0; i < 6; i++) {
        bgClouds.push({
          x: Math.random() * BASE_W,
          y: Math.random() * 160 + 20,
          w: Math.random() * 60 + 40,
          h: Math.random() * 18 + 10,
          s: Math.random() * 0.5 + 0.15
        });
      }
    }

    function resetGame(full = true) {
      bird = {
        x: 78,
        y: BASE_H / 2,
        vy: 0,
        r: 16,
        anim: 0
      };
      pipes = [];
      coins = [];
      particles = [];
      lastPipeTime = performance.now();
      score = 0;
      groundOffset = 0;
      initClouds();
      themeTarget = 0;
      themeLerp = 0;
      if (full) gameState = "home";
    }

    function getThemeTargetFromScore(sc) {
      return Math.floor(sc / 5) % 2;
    }

    function spawnPipe() {
      const maxTop = BASE_H - FLOOR_HEIGHT - 100;
      const minTop = 60;
      const topHeight = Math.floor(Math.random() * (maxTop - minTop) + minTop);
      // moving pipes only after score > 10, and not all of them
      const canMove = score > 10 && Math.random() < 0.35;
      pipes.push({
        x: BASE_W,
        top: topHeight,
        baseTop: topHeight,
        passed: false,
        moving: canMove,
        amp: canMove ? (18 + Math.random() * 18) : 0,
        phase: Math.random() * Math.PI * 2,
        speed: 0.0018 + Math.random() * 0.0013 // slightly different speeds
      });

      if (Math.random() < 0.45) {
        const gapCenter = topHeight + PIPE_GAP / 2;
        coins.push({
          x: BASE_W + PIPE_WIDTH / 2,
          y: gapCenter,
          r: 11,
          t: Math.random() * Math.PI * 2,
          collected: false
        });
      }
    }

    function startPlaying() {
      gameState = "playing";
    }

    function flap() {
      if (gameState === "home") {
        startPlaying();
        return;
      }
      if (gameState === "gameover") {
        resetGame(true);
        return;
      }
      if (gameState === "paused") {
        return;
      }
      bird.vy = FLAP;
      startMusicIfNeeded();
    }

    function startMusicIfNeeded() {
      if (musicStarted || muted) return;
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      musicGain = audioCtx.createGain();
      musicGain.gain.value = 0.48;
      musicGain.connect(audioCtx.destination);

      // simple pop-ish loop: kick (sub), snare-ish noise, lead notes
      const tempo = 110;
      const beat = 60 / tempo;      // quarter
      const bar = beat * 4;         // 4/4 bar

      function scheduleBeat(startTime) {
        for (let i = 0; i < 4; i++) {
          const t = startTime + i * beat;

          // kick: sine + short
          const kick = audioCtx.createOscillator();
          kick.type = "sine";
          const kickGain = audioCtx.createGain();
          kickGain.gain.setValueAtTime(0.9, t);
          kickGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
          kick.frequency.setValueAtTime(95, t);
          kick.frequency.exponentialRampToValueAtTime(35, t + 0.25);
          kick.connect(kickGain).connect(musicGain);
          kick.start(t);
          kick.stop(t + 0.3);

          // snare on beats 2 and 4
          if (i === 1 || i === 3) {
            const snare = audioCtx.createBufferSource();
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.15, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let j = 0; j < data.length; j++) {
              data[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / data.length, 2);
            }
            const snareGain = audioCtx.createGain();
            snareGain.gain.setValueAtTime(0.55, t);
            snareGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            snare.buffer = buffer;
            snare.connect(snareGain).connect(musicGain);
            snare.start(t);
          }

          // lead notes on offbeats
          const notes = [262, 330, 392, 523];
          if (i % 2 === 0) {
            const lead = audioCtx.createOscillator();
            lead.type = "triangle";
            lead.frequency.value = notes[i % notes.length];
            const leadGain = audioCtx.createGain();
            leadGain.gain.setValueAtTime(0, t);
            leadGain.gain.linearRampToValueAtTime(0.4, t + 0.02);
            leadGain.gain.linearRampToValueAtTime(0, t + beat * 0.65);
            lead.connect(leadGain).connect(musicGain);
            lead.start(t);
            lead.stop(t + beat * 0.7);
          }
        }

        // reschedule next bar
        setTimeout(() => {
          if (!muted) scheduleBeat(audioCtx.currentTime + 0.05);
        }, bar * 1000);
      }

      scheduleBeat(audioCtx.currentTime + 0.05);
      musicStarted = true;
    }

    canvas.addEventListener("mousedown", tapHandler);
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      tapHandler(e.touches ? e.touches[0] : e);
    }, {passive:false});

    function tapHandler(e) {
      flap();
    }

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space" || e.code === "ArrowUp") {
        flap();
      }
      if (e.code === "KeyP") togglePause();
      if (e.code === "KeyM") toggleMute();
    });

    pauseBtn.addEventListener("click", () => {
      togglePause();
    });

    muteBtn.addEventListener("click", () => {
      toggleMute();
    });

    function togglePause() {
      if (gameState === "playing") {
        gameState = "paused";
        pauseBtn.textContent = "â–¶";
      } else if (gameState === "paused") {
        gameState = "playing";
        pauseBtn.textContent = "II";
      }
    }

    function toggleMute() {
      muted = !muted;
      if (muted) {
        if (musicGain) musicGain.gain.value = 0;
        muteBtn.textContent = "ðŸ”ˆ";
      } else {
        if (musicGain) musicGain.gain.value = 0.48;
        muteBtn.textContent = "ðŸ”Š";
        startMusicIfNeeded();
      }
    }

    function moveClouds(dt) {
      for (let c of bgClouds) {
        c.x -= c.s;
        if (c.x + c.w < -10) {
          c.x = BASE_W + 30;
          c.y = Math.random() * 160 + 20;
        }
      }
    }

    function spawnCoinBurst(x, y) {
      for (let i = 0; i < 6; i++) {
        particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 1.6) * 2,
          life: 1,
          c: i % 2 === 0 ? "rgba(255,220,120,1)" : "rgba(255,180,60,1)"
        });
      }
    }

    function die() {
      gameState = "gameover";
      try {
        localStorage.setItem("flappyCoins", totalCoins.toString());
        localStorage.setItem("flappyBest", best.toString());
      } catch(e) {}
      pauseBtn.textContent = "II";
    }

    function update(dt, now) {
      // particles
      for (let p of particles) {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.04;
        p.vy += 0.02;
      }
      particles = particles.filter(p => p.life > 0);

      if (gameState === "home") {
        moveClouds(dt);
        bird.y = BASE_H/2 + Math.sin(now * 0.004) * 8;
        return;
      }
      if (gameState === "paused") {
        moveClouds(dt);
        return;
      }
      if (gameState === "gameover") {
        moveClouds(dt);
        return;
      }

      themeTarget = getThemeTargetFromScore(score);
      themeLerp += (themeTarget - themeLerp) * THEME_LERP_SPEED;

      bird.vy += GRAVITY;
      bird.y += bird.vy;
      bird.anim += dt * 0.01;

      if (now - lastPipeTime > PIPE_INTERVAL) {
        spawnPipe();
        lastPipeTime = now;
      }

      for (let p of pipes) {
        // horizontal
        p.x -= SCROLL_SPEED;
        // vertical wiggle for moving pipes
        if (p.moving) {
          p.top = p.baseTop + Math.sin(now * p.speed + p.phase) * p.amp;
          // clamp so gap doesn't go below floor or off-screen
          const maxTop = BASE_H - FLOOR_HEIGHT - 100;
          const minTop = 40;
          if (p.top > maxTop) p.top = maxTop;
          if (p.top < minTop) p.top = minTop;
        }
      }
      pipes = pipes.filter(p => p.x + PIPE_WIDTH > -10);

      for (let c of coins) {
        c.x -= SCROLL_SPEED;
        c.t += dt * 0.008;
      }
      coins = coins.filter(c => !c.collected && c.x + c.r > -10);

      moveClouds(dt);
      groundOffset -= SCROLL_SPEED;
      if (groundOffset <= -72) groundOffset = 0;

      const bx = bird.x;
      const by = bird.y;
      const hitR = bird.r * HITBOX_SHRINK;

      // coin collision
      for (let c of coins) {
        const dx = bx - c.x;
        const dy = by - c.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < hitR + c.r * 0.85) {
          c.collected = true;
          totalCoins += 1;
          spawnCoinBurst(c.x, c.y);
          try { localStorage.setItem("flappyCoins", totalCoins.toString()); } catch(e){}
        }
      }

      // pipes collision + scoring
      for (let p of pipes) {
        const inX = bx + hitR > p.x && bx - hitR < p.x + PIPE_WIDTH;
        const gapTop = p.top;
        const gapBottom = p.top + PIPE_GAP;
        if (inX) {
          const pad = 4;
          if (by - hitR < gapTop - pad || by + hitR > gapBottom + pad) {
            die();
          }
        }
        if (!p.passed && p.x + PIPE_WIDTH < bx) {
          p.passed = true;
          score++;
          if (score > best) best = score;
        }
      }

      if (by + hitR > BASE_H - FLOOR_HEIGHT || by - hitR < 0) {
        die();
      }
    }

    function lerpColor(c1, c2, t) {
      return [
        c1[0] + (c2[0] - c1[0]) * t,
        c1[1] + (c2[1] - c1[1]) * t,
        c1[2] + (c2[2] - c1[2]) * t,
      ];
    }

    // prettier, less "computer" background
    function drawBackground() {
      // sky
      const daySkyTop = [151, 216, 255];
      const daySkyBot = [219, 243, 255];
      const sunsetTop = [253, 183, 144];
      const sunsetBot = [255, 236, 205];

      const top = lerpColor(daySkyTop, sunsetTop, themeLerp);
      const bot = lerpColor(daySkyBot, sunsetBot, themeLerp);

      const grad = ctx.createLinearGradient(0,0,0,BASE_H);
      grad.addColorStop(0, `rgb(${top[0]},${top[1]},${top[2]})`);
      grad.addColorStop(1, `rgb(${bot[0]},${bot[1]},${bot[2]})`);
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,BASE_W,BASE_H);

      // sun
      const sunY = 80 + 40 * themeLerp;
      ctx.fillStyle = `rgba(255,245,220,${0.9 - 0.4*themeLerp})`;
      ctx.beginPath();
      ctx.arc(60, sunY, 38, 0, Math.PI * 2);
      ctx.fill();

      // distant hills
      ctx.fillStyle = `rgba(${70 - 10*themeLerp}, ${130 - 22*themeLerp}, ${95 - 12*themeLerp}, 0.9)`;
      ctx.beginPath();
      ctx.moveTo(0, 280);
      ctx.quadraticCurveTo(90, 230, 180, 270);
      ctx.quadraticCurveTo(260, 300, 360, 260);
      ctx.lineTo(360, 360);
      ctx.lineTo(0, 360);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = `rgba(${50 - 15*themeLerp}, ${105 - 20*themeLerp}, ${73 - 15*themeLerp}, 0.7)`;
      ctx.beginPath();
      ctx.moveTo(0, 310);
      ctx.quadraticCurveTo(45, 280, 130, 315);
      ctx.quadraticCurveTo(220, 348, 360, 320);
      ctx.lineTo(360, 380);
      ctx.lineTo(0, 380);
      ctx.closePath();
      ctx.fill();

      // clouds
      for (let c of bgClouds) {
        const cloudAlpha = 0.8 - 0.5 * themeLerp;
        ctx.fillStyle = `rgba(255,255,255,${cloudAlpha})`;
        ctx.beginPath();
        ctx.roundRect(c.x, c.y, c.w, c.h, 12);
        ctx.fill();
      }
    }

    function drawPipes() {
      for (let p of pipes) {
        const c1 = lerpColor([46,159,69],[43,58,85], themeLerp);
        const c2 = lerpColor([62,207,91],[61,83,116], themeLerp);
        const c3 = lerpColor([43,127,59],[31,40,55], themeLerp);
        const grad = ctx.createLinearGradient(p.x, 0, p.x + PIPE_WIDTH, 0);
        grad.addColorStop(0, `rgb(${c1[0]},${c1[1]},${c1[2]})`);
        grad.addColorStop(0.5, `rgb(${c2[0]},${c2[1]},${c2[2]})`);
        grad.addColorStop(1, `rgb(${c3[0]},${c3[1]},${c3[2]})`);
        ctx.fillStyle = grad;

        ctx.fillRect(p.x, 0, PIPE_WIDTH, p.top);
        const lipColor = `rgba(${Math.floor(217 - 60*themeLerp)},${Math.floor(255 - 60*themeLerp)},${Math.floor(212 - 60*themeLerp)},${1 - 0.4*themeLerp})`;
        ctx.fillStyle = lipColor;
        ctx.fillRect(p.x - 3, p.top - 16, PIPE_WIDTH + 6, 16);

        const bottomH = BASE_H - FLOOR_HEIGHT - (p.top + PIPE_GAP);
        ctx.fillStyle = grad;
        ctx.fillRect(p.x, p.top + PIPE_GAP, PIPE_WIDTH, bottomH);
        ctx.fillStyle = lipColor;
        ctx.fillRect(p.x - 3, p.top + PIPE_GAP, PIPE_WIDTH + 6, 16);

        // mark moving pipes subtly
        if (p.moving) {
          ctx.fillStyle = "rgba(255,255,255,0.35)";
          ctx.fillRect(p.x + PIPE_WIDTH/2 - 4, p.top - 22, 8, 8);
        }
      }
    }

    function drawGround() {
      const groundCol = lerpColor([212,170,99],[47,43,50], themeLerp);
      ctx.fillStyle = `rgb(${groundCol[0]},${groundCol[1]},${groundCol[2]})`;
      ctx.fillRect(0, BASE_H - FLOOR_HEIGHT, BASE_W, FLOOR_HEIGHT);

      const grassCol = lerpColor([99,184,64],[63,95,72], themeLerp);
      ctx.fillStyle = `rgb(${grassCol[0]},${grassCol[1]},${grassCol[2]})`;
      ctx.fillRect(0, BASE_H - FLOOR_HEIGHT, BASE_W, 14);

      const patternAlpha = 0.1 - 0.06 * themeLerp;
      ctx.fillStyle = `rgba(0,0,0,${Math.max(patternAlpha,0)})`;
      for (let x = groundOffset; x < BASE_W + 72; x += 72) {
        ctx.fillRect(x, BASE_H - FLOOR_HEIGHT + 16, 48, 14);
      }
    }

    function drawBird() {
      ctx.save();
      ctx.translate(bird.x, bird.y);
      const tilt = (gameState === "home")
        ? Math.sin(performance.now() * 0.004) * 0.15
        : Math.min(Math.max(bird.vy / 10, -0.45), 0.6);
      ctx.rotate(tilt);

      const base1 = lerpColor([255,217,102],[255,226,168], themeLerp);
      const base2 = lerpColor([255,174,0],[255,193,78], themeLerp);
      const wingCol = lerpColor([255,233,168],[255,244,216], themeLerp);
      const cheekCol = lerpColor([255,120,120],[255,196,196], themeLerp);
      const beakCol = lerpColor([255,123,26],[255,156,70], themeLerp);

      const grd = ctx.createLinearGradient(-12, -16, 24, 16);
      grd.addColorStop(0, `rgb(${base1[0]},${base1[1]},${base1[2]})`);
      grd.addColorStop(1, `rgb(${base2[0]},${base2[1]},${base2[2]})`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(0, 0, 20, 16, 0, 0, Math.PI * 2);
      ctx.fill();

      const wingOffset = Math.sin(bird.anim * 8) * 4;
      ctx.save();
      ctx.translate(-6, 4 + wingOffset);
      ctx.fillStyle = `rgb(${wingCol[0]},${wingCol[1]},${wingCol[2]})`;
      ctx.beginPath();
      ctx.roundRect(-10, -6, 20, 12, 6);
      ctx.fill();
      ctx.restore();

      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(9, -6, 5.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(11, -6, 2.4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = `rgba(${cheekCol[0]},${cheekCol[1]},${cheekCol[2]},0.6)`;
      ctx.beginPath();
      ctx.arc(-3, 4, 3.6, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = `rgb(${beakCol[0]},${beakCol[1]},${beakCol[2]})`;
      ctx.beginPath();
      ctx.moveTo(18, -2);
      ctx.lineTo(30, 2);
      ctx.lineTo(18, 6);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawCoins() {
      for (let c of coins) {
        const glowRadius = c.r * 2.1;
        ctx.save();
        ctx.globalAlpha = 0.35 + 0.25 * Math.sin(c.t * 2);
        const gradGlow = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, glowRadius);
        gradGlow.addColorStop(0, "rgba(255,220,120,1)");
        gradGlow.addColorStop(1, "rgba(255,220,120,0)");
        ctx.fillStyle = gradGlow;
        ctx.beginPath();
        ctx.arc(c.x, c.y, glowRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        const spin = (Math.sin(c.t * 3) * 0.35) + 1;
        const rX = c.r * spin;
        const rY = c.r;

        const coinGrad = ctx.createRadialGradient(c.x - 3, c.y - 4, 2, c.x, c.y, rY + 2);
        coinGrad.addColorStop(0, "#fff9d6");
        coinGrad.addColorStop(0.4, "#ffd447");
        coinGrad.addColorStop(1, "#c97a1a");
        ctx.fillStyle = coinGrad;
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, rX, rY, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.ellipse(c.x - 1, c.y - 3, rX / 2.3, rY / 2, 0, Math.PI * 1.2, Math.PI * 1.7);
        ctx.stroke();
      }
    }

    function drawParticles() {
      for (let p of particles) {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.c;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.roundRect(10, 10, 150, 54, 10);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 26px system-ui, sans-serif";
      ctx.fillText(score.toString(), 20, 42);

      ctx.fillStyle = "#fff";
      ctx.font = "12px system-ui, sans-serif";
      ctx.fillText("Coins: " + totalCoins, 80, 28);
      ctx.fillText("Best: " + best, 80, 44);
    }

    function drawHomeScreen() {
      ctx.fillStyle = "rgba(2,6,23,0.35)";
      ctx.beginPath();
      ctx.roundRect(40, 120, BASE_W - 80, 260, 22);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 30px system-ui, sans-serif";
      ctx.fillText("FLAPPY", 112, 160);
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText("tap to start", 132, 188);

      ctx.font = "12px system-ui, sans-serif";
      ctx.fillText("score: " + score, 132, 212);
      ctx.fillText("best: " + best, 132, 230);

      ctx.font = "11px system-ui, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.fillText("collect coins. avoid pipes.", 95, 260);
      ctx.fillText("auto-fit to screen, no distortion.", 78, 280);
    }

    function drawGameOver() {
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(0, 0, BASE_W, BASE_H);

      const cardW = 260, cardH = 200;
      const cx = (BASE_W - cardW)/2;
      const cy = (BASE_H - cardH)/2;
      ctx.fillStyle = "rgba(255,255,255,0.98)";
      ctx.beginPath();
      ctx.roundRect(cx, cy, cardW, cardH, 16);
      ctx.fill();

      ctx.fillStyle = "#0f172a";
      ctx.font = "bold 26px system-ui, sans-serif";
      ctx.fillText("GAME OVER", cx + 42, cy + 42);

      ctx.fillStyle = "#334155";
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText("Score: " + score, cx + 30, cy + 78);
      ctx.fillText("Best: " + best, cx + 30, cy + 100);
      ctx.fillText("Coins: " + totalCoins, cx + 30, cy + 122);

      const bw = cardW - 50, bh = 44;
      const bx = cx + 25, by = cy + 134;
      const btnGrad = ctx.createLinearGradient(bx, by, bx + bw, by + bh);
      btnGrad.addColorStop(0, "#38bdf8");
      btnGrad.addColorStop(1, "#0ea5e9");
      ctx.fillStyle = btnGrad;
      ctx.beginPath();
      ctx.roundRect(bx, by, bw, bh, 12);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText("tap to restart", bx + 58, by + 27);
    }

    let last = performance.now();
    function loop(now) {
      const dt = now - last;
      last = now;
      update(dt, now);

      ctx.clearRect(0, 0, BASE_W, BASE_H);
      drawBackground();
      drawPipes();
      drawGround();
      drawCoins();
      drawParticles();
      drawBird();

      if (gameState === "home") {
        drawHomeScreen();
      } else if (gameState === "playing") {
        drawHUD();
      } else if (gameState === "paused") {
        drawHUD();
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(0, 0, BASE_W, BASE_H);
        ctx.fillStyle = "#fff";
        ctx.font = "bold 32px system-ui, sans-serif";
        ctx.fillText("PAUSED", 108, BASE_H/2);
      } else if (gameState === "gameover") {
        drawHUD();
        drawGameOver();
      }

      requestAnimationFrame(loop);
    }

    resetGame(true);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
