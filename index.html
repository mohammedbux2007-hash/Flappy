<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Clean</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #020617;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: manipulation;
    }
    #gameWrap {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: 480px;
      max-height: 900px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      display: block;
      background: #7ed0ff;
      border-radius: 18px;
      box-shadow: 0 20px 45px rgba(0,0,0,0.35);
      image-rendering: optimizeSpeed;
      image-rendering: -webkit-optimize-contrast;
    }
    .top-ui {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    .btn {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      background: rgba(0,0,0,0.38);
      border: 1px solid rgba(255,255,255,0.12);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      backdrop-filter: blur(4px);
      touch-action: manipulation;
      user-select: none;
    }
    .btn:active {
      transform: scale(0.94);
    }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game"></canvas>
    <div class="top-ui">
      <div class="btn" id="pauseBtn" title="Pause">II</div>
      <div class="btn" id="muteBtn" title="Mute">ðŸ”Š</div>
    </div>
  </div>

  <script>
    const BASE_W = 360;
    const BASE_H = 540;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    canvas.width = BASE_W;
    canvas.height = BASE_H;

    function fitCanvas() {
      const wrap = document.getElementById("gameWrap");
      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      const scale = Math.min(w / BASE_W, h / BASE_H);
      canvas.style.width = BASE_W * scale + "px";
      canvas.style.height = BASE_H * scale + "px";
    }
    window.addEventListener("resize", fitCanvas);
    fitCanvas();

    // states: "home", "playing", "paused", "gameover", "store"
    let gameState = "home";

    const GRAVITY = 0.29;
    const FLAP = -6.5;
    const PIPE_GAP = 160;
    const PIPE_WIDTH = 64;
    const PIPE_INTERVAL = 1550;
    const FLOOR_HEIGHT = 76;
    const SCROLL_SPEED = 1.8;
    const HITBOX_SHRINK = 0.7;

    // skins/store
    const SKINS = [
      { id: "bird", name: "Classic Bird", price: 0, unlockMeters: 0 },
      { id: "skeleton", name: "Skeleton Bird", price: 100, unlockMeters: 0 },
      { id: "ghost", name: "Ghost", price: 250, unlockMeters: 0 },
      { id: "plane", name: "Aeroplane", price: 0, unlockMeters: 500 }
    ];
    let activeSkin = "bird";
    let ownedSkins = { bird: true };
    let maxMetersReached = 0;

    let themeLerp = 0;
    let themeTarget = 0;
    const THEME_LERP_SPEED = 0.08;

    let bird, pipes, lastPipeTime, score, best, bgClouds, groundOffset;
    best = 0;
    let coins = [];
    let totalCoins = 0;
    let particles = [];

    // home buttons
    const homeButtons = {
      play: { x: 90, y: 220, w: 180, h: 50 },
      store: { x: 130, y: 284, w: 100, h: 38 }
    };

    // audio
    let audioCtx = null;
    let musicGain = null;
    let musicStarted = false;
    let muted = false;

    const pauseBtn = document.getElementById("pauseBtn");
    const muteBtn = document.getElementById("muteBtn");

    // load from localStorage
    try {
      const savedCoins = localStorage.getItem("flappyCoins");
      if (savedCoins !== null) totalCoins = parseInt(savedCoins, 10) || 0;
      const savedBest = localStorage.getItem("flappyBest");
      if (savedBest !== null) best = parseInt(savedBest, 10) || 0;
      const savedSkins = localStorage.getItem("flappyOwnedSkins");
      if (savedSkins) {
        ownedSkins = JSON.parse(savedSkins);
      }
      const savedActive = localStorage.getItem("flappyActiveSkin");
      if (savedActive) {
        activeSkin = savedActive;
      }
      const savedMeters = localStorage.getItem("flappyMaxMeters");
      if (savedMeters) {
        maxMetersReached = parseInt(savedMeters, 10) || 0;
      }
    } catch(e) {}

    function saveProgress() {
      try {
        localStorage.setItem("flappyCoins", totalCoins.toString());
        localStorage.setItem("flappyBest", best.toString());
        localStorage.setItem("flappyOwnedSkins", JSON.stringify(ownedSkins));
        localStorage.setItem("flappyActiveSkin", activeSkin);
        localStorage.setItem("flappyMaxMeters", maxMetersReached.toString());
      } catch(e) {}
    }

    function initClouds() {
      bgClouds = [];
      for (let i = 0; i < 6; i++) {
        bgClouds.push({
          x: Math.random() * BASE_W,
          y: Math.random() * 160 + 20,
          w: Math.random() * 60 + 40,
          h: Math.random() * 18 + 10,
          s: Math.random() * 0.5 + 0.15
        });
      }
    }

    function resetGame(full = true) {
      bird = {
        x: 78,
        y: BASE_H / 2,
        vy: 0,
        r: 16,
        anim: 0
      };
      pipes = [];
      coins = [];
      particles = [];
      lastPipeTime = performance.now();
      score = 0;
      groundOffset = 0;
      initClouds();
      themeTarget = 0;
      themeLerp = 0;
      if (full) gameState = "home";
    }

    function getThemeTargetFromScore(sc) {
      return Math.floor(sc / 5) % 2;
    }

    function spawnPipe() {
      const maxTop = BASE_H - FLOOR_HEIGHT - 100;
      const minTop = 60;
      const topHeight = Math.floor(Math.random() * (maxTop - minTop) + minTop);
      const canMove = score > 10 && Math.random() < 0.35;
      pipes.push({
        x: BASE_W,
        top: topHeight,
        baseTop: topHeight,
        passed: false,
        moving: canMove,
        amp: canMove ? (18 + Math.random() * 18) : 0,
        phase: Math.random() * Math.PI * 2,
        speed: 0.0018 + Math.random() * 0.0013
      });

      if (Math.random() < 0.45) {
        const gapCenter = topHeight + PIPE_GAP / 2;
        coins.push({
          x: BASE_W + PIPE_WIDTH / 2,
          y: gapCenter,
          r: 11,
          t: Math.random() * Math.PI * 2,
          collected: false
        });
      }
    }

    function startPlaying() {
      gameState = "playing";
    }

    function flap() {
      if (gameState === "home") {
        startPlaying();
        return;
      }
      if (gameState === "gameover") {
        resetGame(true);
        return;
      }
      if (gameState === "paused" || gameState === "store") {
        return;
      }
      bird.vy = FLAP;
      startMusicIfNeeded();
    }

    function startMusicIfNeeded() {
      if (musicStarted || muted) return;
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      musicGain = audioCtx.createGain();
      musicGain.gain.value = 0.48;
      musicGain.connect(audioCtx.destination);

      const tempo = 110;
      const beat = 60 / tempo;
      const bar = beat * 4;

      function scheduleBeat(startTime) {
        for (let i = 0; i < 4; i++) {
          const t = startTime + i * beat;

          // kick
          const kick = audioCtx.createOscillator();
          kick.type = "sine";
          const kickGain = audioCtx.createGain();
          kickGain.gain.setValueAtTime(0.9, t);
          kickGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
          kick.frequency.setValueAtTime(95, t);
          kick.frequency.exponentialRampToValueAtTime(35, t + 0.25);
          kick.connect(kickGain).connect(musicGain);
          kick.start(t);
          kick.stop(t + 0.3);

          // snare (2 and 4)
          if (i === 1 || i === 3) {
            const snare = audioCtx.createBufferSource();
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.15, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let j = 0; j < data.length; j++) {
              data[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / data.length, 2);
            }
            const snareGain = audioCtx.createGain();
            snareGain.gain.setValueAtTime(0.55, t);
            snareGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            snare.buffer = buffer;
            snare.connect(snareGain).connect(musicGain);
            snare.start(t);
          }

          // lead
          const notes = [262, 330, 392, 523];
          if (i % 2 === 0) {
            const lead = audioCtx.createOscillator();
            lead.type = "triangle";
            lead.frequency.value = notes[i % notes.length];
            const leadGain = audioCtx.createGain();
            leadGain.gain.setValueAtTime(0, t);
            leadGain.gain.linearRampToValueAtTime(0.4, t + 0.02);
            leadGain.gain.linearRampToValueAtTime(0, t + beat * 0.65);
            lead.connect(leadGain).connect(musicGain);
            lead.start(t);
            lead.stop(t + beat * 0.7);
          }
        }

        setTimeout(() => {
          if (!muted) scheduleBeat(audioCtx.currentTime + 0.05);
        }, bar * 1000);
      }

      scheduleBeat(audioCtx.currentTime + 0.05);
      musicStarted = true;
    }

    canvas.addEventListener("mousedown", tapHandler);
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      tapHandler(e.touches ? e.touches[0] : e);
    }, {passive:false});

    function pointInRect(px, py, rect) {
      return px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h;
    }

    function tapHandler(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (BASE_W / rect.width);
      const my = (e.clientY - rect.top) * (BASE_H / rect.height);

      if (gameState === "home") {
        if (pointInRect(mx, my, homeButtons.play)) {
          startPlaying();
          return;
        }
        if (pointInRect(mx, my, homeButtons.store)) {
          gameState = "store";
          return;
        }
        return;
      }

      if (gameState === "store") {
        const storeRects = getStoreRects();
        for (let s of storeRects) {
          if (pointInRect(mx, my, s.rect)) {
            onStoreSelect(s.skin);
            return;
          }
        }
        return;
      }

      flap();
    }

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space" || e.code === "ArrowUp") {
        flap();
      }
      if (e.code === "KeyP") togglePause();
      if (e.code === "KeyM") toggleMute();
      if (e.code === "Escape" && gameState === "store") {
        gameState = "home";
      }
    });

    pauseBtn.addEventListener("click", () => {
      togglePause();
    });

    muteBtn.addEventListener("click", () => {
      toggleMute();
    });

    function togglePause() {
      if (gameState === "playing") {
        gameState = "paused";
        pauseBtn.textContent = "â–¶";
      } else if (gameState === "paused") {
        gameState = "playing";
        pauseBtn.textContent = "II";
      }
    }

    function toggleMute() {
      muted = !muted;
      if (muted) {
        if (musicGain) musicGain.gain.value = 0;
        muteBtn.textContent = "ðŸ”ˆ";
      } else {
        if (musicGain) musicGain.gain.value = 0.48;
        muteBtn.textContent = "ðŸ”Š";
        startMusicIfNeeded();
      }
    }

    function moveClouds(dt) {
      for (let c of bgClouds) {
        c.x -= c.s;
        if (c.x + c.w < -10) {
          c.x = BASE_W + 30;
          c.y = Math.random() * 160 + 20;
        }
      }
    }

    function spawnCoinBurst(x, y) {
      for (let i = 0; i < 6; i++) {
        particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 1.6) * 2,
          life: 1,
          c: i % 2 === 0 ? "rgba(255,220,120,1)" : "rgba(255,180,60,1)"
        });
      }
    }

    function die() {
      gameState = "gameover";
      saveProgress();
      pauseBtn.textContent = "II";
    }

    function update(dt, now) {
      // particles
      for (let p of particles) {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.04;
        p.vy += 0.02;
      }
      particles = particles.filter(p => p.life > 0);

      if (gameState === "home" || gameState === "store") {
        moveClouds(dt);
        if (gameState === "home") {
          bird.y = BASE_H/2 + Math.sin(now * 0.004) * 8;
        }
        return;
      }
      if (gameState === "paused") {
        moveClouds(dt);
        return;
      }
      if (gameState === "gameover") {
        moveClouds(dt);
        return;
      }

      // playing
      themeTarget = getThemeTargetFromScore(score);
      themeLerp += (themeTarget - themeLerp) * THEME_LERP_SPEED;

      bird.vy += GRAVITY;
      bird.y += bird.vy;
      bird.anim += dt * 0.01;

      if (now - lastPipeTime > PIPE_INTERVAL) {
        spawnPipe();
        lastPipeTime = now;
      }

      for (let p of pipes) {
        p.x -= SCROLL_SPEED;
        if (p.moving) {
          p.top = p.baseTop + Math.sin(now * p.speed + p.phase) * p.amp;
          const maxTop = BASE_H - FLOOR_HEIGHT - 100;
          const minTop = 40;
          if (p.top > maxTop) p.top = maxTop;
          if (p.top < minTop) p.top = minTop;
        }
      }
      pipes = pipes.filter(p => p.x + PIPE_WIDTH > -10);

      for (let c of coins) {
        c.x -= SCROLL_SPEED;
        c.t += dt * 0.008;
      }
      coins = coins.filter(c => !c.collected && c.x + c.r > -10);

      moveClouds(dt);
      groundOffset -= SCROLL_SPEED;
      if (groundOffset <= -72) groundOffset = 0;

      const bx = bird.x;
      const by = bird.y;
      const hitR = bird.r * HITBOX_SHRINK;

      // coin collision
      for (let c of coins) {
        const dx = bx - c.x;
        const dy = by - c.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < hitR + c.r * 0.85) {
          c.collected = true;
          totalCoins += 1;
          spawnCoinBurst(c.x, c.y);
          saveProgress();
        }
      }

      // pipes collision + scoring
      for (let p of pipes) {
        const inX = bx + hitR > p.x && bx - hitR < p.x + PIPE_WIDTH;
        const gapTop = p.top;
        const gapBottom = p.top + PIPE_GAP;
        if (inX) {
          const pad = 4;
          if (by - hitR < gapTop - pad || by + hitR > gapBottom + pad) {
            die();
          }
        }
        if (!p.passed && p.x + PIPE_WIDTH < bx) {
          p.passed = true;
          score++;
          if (score > best) best = score;

          const metersNow = Math.floor(score / 2) * 100;
          if (metersNow > maxMetersReached) {
            maxMetersReached = metersNow;
            saveProgress();
          }
        }
      }

      if (by + hitR > BASE_H - FLOOR_HEIGHT || by - hitR < 0) {
        die();
      }
    }

    function lerpColor(c1, c2, t) {
      return [
        c1[0] + (c2[0] - c1[0]) * t,
        c1[1] + (c2[1] - c1[1]) * t,
        c1[2] + (c2[2] - c1[2]) * t,
      ];
    }

    // background
    function drawBackground() {
      const daySkyTop = [151, 216, 255];
      const daySkyBot = [219, 243, 255];
      const sunsetTop = [253, 183, 144];
      const sunsetBot = [255, 236, 205];

      const top = lerpColor(daySkyTop, sunsetTop, themeLerp);
      const bot = lerpColor(daySkyBot, sunsetBot, themeLerp);

      const grad = ctx.createLinearGradient(0,0,0,BASE_H);
      grad.addColorStop(0, `rgb(${top[0]},${top[1]},${top[2]})`);
      grad.addColorStop(1, `rgb(${bot[0]},${bot[1]},${bot[2]})`);
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,BASE_W,BASE_H);

      const sunY = 80 + 40 * themeLerp;
      ctx.fillStyle = `rgba(255,245,220,${0.9 - 0.4*themeLerp})`;
      ctx.beginPath();
      ctx.arc(60, sunY, 38, 0, Math.PI * 2);
      ctx.fill();

      // distant hills
      ctx.fillStyle = `rgba(${70 - 10*themeLerp}, ${130 - 22*themeLerp}, ${95 - 12*themeLerp}, 0.9)`;
      ctx.beginPath();
      ctx.moveTo(0, 280);
      ctx.quadraticCurveTo(90, 230, 180, 270);
      ctx.quadraticCurveTo(260, 300, 360, 260);
      ctx.lineTo(360, 360);
      ctx.lineTo(0, 360);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = `rgba(${50 - 15*themeLerp}, ${105 - 20*themeLerp}, ${73 - 15*themeLerp}, 0.7)`;
      ctx.beginPath();
      ctx.moveTo(0, 310);
      ctx.quadraticCurveTo(45, 280, 130, 315);
      ctx.quadraticCurveTo(220, 348, 360, 320);
      ctx.lineTo(360, 380);
      ctx.lineTo(0, 380);
      ctx.closePath();
      ctx.fill();

      // clouds
      for (let c of bgClouds) {
        const cloudAlpha = 0.8 - 0.5 * themeLerp;
        ctx.fillStyle = `rgba(255,255,255,${cloudAlpha})`;
        ctx.beginPath();
        ctx.roundRect(c.x, c.y, c.w, c.h, 12);
        ctx.fill();
      }
    }

    function drawPipes() {
      for (let p of pipes) {
        const c1 = lerpColor([46,159,69],[43,58,85], themeLerp);
        const c2 = lerpColor([62,207,91],[61,83,116], themeLerp);
        const c3 = lerpColor([43,127,59],[31,40,55], themeLerp);
        const grad = ctx.createLinearGradient(p.x, 0, p.x + PIPE_WIDTH, 0);
        grad.addColorStop(0, `rgb(${c1[0]},${c1[1]},${c1[2]})`);
        grad.addColorStop(0.5, `rgb(${c2[0]},${c2[1]},${c2[2]})`);
        grad.addColorStop(1, `rgb(${c3[0]},${c3[1]},${c3[2]})`);
        ctx.fillStyle = grad;

        ctx.fillRect(p.x, 0, PIPE_WIDTH, p.top);
        const lipColor = `rgba(${Math.floor(217 - 60*themeLerp)},${Math.floor(255 - 60*themeLerp)},${Math.floor(212 - 60*themeLerp)},${1 - 0.4*themeLerp})`;
        ctx.fillStyle = lipColor;
        ctx.fillRect(p.x - 3, p.top - 16, PIPE_WIDTH + 6, 16);

        const bottomH = BASE_H - FLOOR_HEIGHT - (p.top + PIPE_GAP);
        ctx.fillStyle = grad;
        ctx.fillRect(p.x, p.top + PIPE_GAP, PIPE_WIDTH, bottomH);
        ctx.fillStyle = lipColor;
        ctx.fillRect(p.x - 3, p.top + PIPE_GAP, PIPE_WIDTH + 6, 16);

        if (p.moving) {
          ctx.fillStyle = "rgba(255,255,255,0.35)";
          ctx.fillRect(p.x + PIPE_WIDTH/2 - 4, p.top - 22, 8, 8);
        }
      }
    }

    function drawGround() {
      const groundCol = lerpColor([212,170,99],[47,43,50], themeLerp);
      ctx.fillStyle = `rgb(${groundCol[0]},${groundCol[1]},${groundCol[2]})`;
      ctx.fillRect(0, BASE_H - FLOOR_HEIGHT, BASE_W, FLOOR_HEIGHT);

      const grassCol = lerpColor([99,184,64],[63,95,72], themeLerp);
      ctx.fillStyle = `rgb(${grassCol[0]},${grassCol[1]},${grassCol[2]})`;
      ctx.fillRect(0, BASE_H - FLOOR_HEIGHT, BASE_W, 14);

      const patternAlpha = 0.1 - 0.06 * themeLerp;
      ctx.fillStyle = `rgba(0,0,0,${Math.max(patternAlpha,0)})`;
      for (let x = groundOffset; x < BASE_W + 72; x += 72) {
        ctx.fillRect(x, BASE_H - FLOOR_HEIGHT + 16, 48, 14);
      }
    }

    // prettier skins
    function drawSkinBird() {
      // shadow
      ctx.save();
      ctx.globalAlpha = 0.28;
      ctx.beginPath();
      ctx.ellipse(1, 10, 16, 6, 0, 0, Math.PI * 2);
      ctx.fillStyle = "#000";
      ctx.fill();
      ctx.restore();

      // body
      const bodyGrad = ctx.createLinearGradient(-16, -16, 20, 16);
      bodyGrad.addColorStop(0, "#ffe28a");
      bodyGrad.addColorStop(0.6, "#ffb347");
      bodyGrad.addColorStop(1, "#ff9447");
      ctx.fillStyle = bodyGrad;
      ctx.beginPath();
      ctx.ellipse(0, 0, 20, 16, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.lineWidth = 1.4;
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.stroke();

      // belly highlight
      const belly = ctx.createRadialGradient(-6, 4, 0, -6, 4, 15);
      belly.addColorStop(0, "rgba(255,255,255,0.7)");
      belly.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = belly;
      ctx.beginPath();
      ctx.ellipse(-4, 3, 12, 9, 0.1, 0, Math.PI * 2);
      ctx.fill();

      // wing
      const wingOffset = Math.sin(bird.anim * 8) * 4;
      ctx.save();
      ctx.translate(-6, 3 + wingOffset);
      ctx.rotate(-0.2);
      const wingGrad = ctx.createLinearGradient(-10, -6, 12, 6);
      wingGrad.addColorStop(0, "#fff3d9");
      wingGrad.addColorStop(1, "#f4c47e");
      ctx.fillStyle = wingGrad;
      ctx.beginPath();
      ctx.roundRect(-11, -7, 22, 14, 8);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.12)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();

      // eye
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(9, -6, 5.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 0.8;
      ctx.stroke();

      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(11, -6, 2.7, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.beginPath();
      ctx.arc(10, -7, 1, 0, Math.PI * 2);
      ctx.fill();

      // cheek
      ctx.fillStyle = "rgba(255,99,132,0.4)";
      ctx.beginPath();
      ctx.arc(-2, 5, 3.5, 0, Math.PI * 2);
      ctx.fill();

      // beak
      const beakGrad = ctx.createLinearGradient(18, -2, 34, 4);
      beakGrad.addColorStop(0, "#ffeb99");
      beakGrad.addColorStop(1, "#ffb347");
      ctx.fillStyle = beakGrad;
      ctx.beginPath();
      ctx.moveTo(18, -2);
      ctx.lineTo(34, 2);
      ctx.lineTo(18, 6);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.2)";
      ctx.lineWidth = 0.7;
      ctx.stroke();
    }

    function drawSkinSkeleton() {
      // shadow
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.ellipse(1, 10, 15, 5, 0, 0, Math.PI * 2);
      ctx.fillStyle = "#000";
      ctx.fill();
      ctx.restore();

      // skull body
      const skullGrad = ctx.createLinearGradient(-16, -16, 20, 18);
      skullGrad.addColorStop(0, "#ffffff");
      skullGrad.addColorStop(1, "#d1d5db");
      ctx.fillStyle = skullGrad;
      ctx.beginPath();
      ctx.ellipse(0, 0, 19, 16, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 1.2;
      ctx.stroke();

      // crack
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 0.7;
      ctx.beginPath();
      ctx.moveTo(-6, -7);
      ctx.lineTo(-2, -9);
      ctx.lineTo(1, -6);
      ctx.stroke();

      // eye hole
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(6, -3, 4.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.4)";
      ctx.beginPath();
      ctx.arc(4.5, -4.2, 1.2, 0, Math.PI * 2);
      ctx.fill();

      // teeth
      ctx.fillStyle = "#e5e7eb";
      ctx.beginPath();
      ctx.roundRect(-4, 4, 9, 5, 2);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 0.5;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-1, 4);
      ctx.lineTo(-1, 9);
      ctx.moveTo(2, 4);
      ctx.lineTo(2, 9);
      ctx.stroke();

      // bony wing
      const wingOff = Math.sin(bird.anim * 7) * 3;
      ctx.save();
      ctx.translate(-8, 3 + wingOff);
      ctx.fillStyle = "#f3f4f6";
      ctx.beginPath();
      ctx.roundRect(-10, -5, 20, 10, 5);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.15)";
      ctx.stroke();
      ctx.restore();

      // bone beak
      ctx.fillStyle = "#d4d4d8";
      ctx.beginPath();
      ctx.moveTo(15, -1);
      ctx.lineTo(28, 1);
      ctx.lineTo(15, 6);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.15)";
      ctx.stroke();
    }

    function drawSkinGhost() {
      // glow
      const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 26);
      glow.addColorStop(0, "rgba(255,255,255,0.9)");
      glow.addColorStop(1, "rgba(255,255,255,0)");
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0, 0, 26, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // body
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(0, 0, 15, 17, 0, 0, Math.PI * 2);
      ctx.fill();

      // bottom waves
      ctx.beginPath();
      ctx.moveTo(-15, 6);
      ctx.quadraticCurveTo(-8, 14, -4, 8);
      ctx.quadraticCurveTo(0, 14, 4, 8);
      ctx.quadraticCurveTo(8, 14, 15, 6);
      ctx.lineTo(15, 16);
      ctx.lineTo(-15, 16);
      ctx.closePath();
      ctx.fill();

      // eyes
      ctx.fillStyle = "#0f172a";
      ctx.beginPath();
      ctx.arc(-4, -3, 2.4, 0, Math.PI * 2);
      ctx.arc(4, -3, 2.4, 0, Math.PI * 2);
      ctx.fill();

      // mouth
      ctx.beginPath();
      ctx.arc(0, 3, 3.2, 0, Math.PI);
      ctx.fillStyle = "rgba(15,23,42,0.8)";
      ctx.fill();

      // outline
      ctx.strokeStyle = "rgba(148,163,184,0.35)";
      ctx.lineWidth = 1.1;
      ctx.beginPath();
      ctx.ellipse(0, 0, 15, 17, 0, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawSkinPlane() {
      // shadow
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.ellipse(0, 9, 20, 6, 0, 0, Math.PI * 2);
      ctx.fillStyle = "#000";
      ctx.fill();
      ctx.restore();

      // main body
      const body = ctx.createLinearGradient(-24, 0, 28, 0);
      body.addColorStop(0, "#e2e8f0");
      body.addColorStop(0.5, "#ffffff");
      body.addColorStop(1, "#cbd5f5");
      ctx.fillStyle = body;
      ctx.beginPath();
      ctx.roundRect(-24, -6, 48, 12, 6);
      ctx.fill();
      ctx.strokeStyle = "rgba(15,23,42,0.45)";
      ctx.lineWidth = 1;
      ctx.stroke();

      // nose
      ctx.fillStyle = "#38bdf8";
      ctx.beginPath();
      ctx.roundRect(16, -6, 14, 12, 6);
      ctx.fill();

      // top wing
      ctx.fillStyle = "rgba(148,163,184,0.95)";
      ctx.beginPath();
      ctx.moveTo(-8, -6);
      ctx.lineTo(-20, -16);
      ctx.lineTo(4, -6);
      ctx.closePath();
      ctx.fill();

      // bottom wing
      ctx.beginPath();
      ctx.moveTo(-8, 6);
      ctx.lineTo(-20, 16);
      ctx.lineTo(4, 6);
      ctx.closePath();
      ctx.fill();

      // tail
      ctx.fillStyle = "rgba(148,163,184,0.85)";
      ctx.beginPath();
      ctx.moveTo(-20, -6);
      ctx.lineTo(-26, -16);
      ctx.lineTo(-16, -6);
      ctx.closePath();
      ctx.fill();

      // window
      ctx.fillStyle = "#0f172a";
      ctx.beginPath();
      ctx.arc(6, -1, 2.3, 0, Math.PI * 2);
      ctx.fill();

      // window gloss
      ctx.fillStyle = "rgba(255,255,255,0.6)";
      ctx.beginPath();
      ctx.arc(5.2, -1.6, 0.8, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawBird() {
      ctx.save();
      ctx.translate(bird.x, bird.y);
      const tilt = (gameState === "home" || gameState === "store")
        ? Math.sin(performance.now() * 0.004) * 0.15
        : Math.min(Math.max(bird.vy / 10, -0.45), 0.6);
      ctx.rotate(tilt);

      if (activeSkin === "bird") {
        drawSkinBird();
      } else if (activeSkin === "skeleton") {
        drawSkinSkeleton();
      } else if (activeSkin === "ghost") {
        drawSkinGhost();
      } else if (activeSkin === "plane") {
        drawSkinPlane();
      } else {
        drawSkinBird();
      }

      ctx.restore();
    }

    function drawCoins() {
      for (let c of coins) {
        const glowRadius = c.r * 2.1;
        ctx.save();
        ctx.globalAlpha = 0.35 + 0.25 * Math.sin(c.t * 2);
        const gradGlow = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, glowRadius);
        gradGlow.addColorStop(0, "rgba(255,220,120,1)");
        gradGlow.addColorStop(1, "rgba(255,220,120,0)");
        ctx.fillStyle = gradGlow;
        ctx.beginPath();
        ctx.arc(c.x, c.y, glowRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        const spin = (Math.sin(c.t * 3) * 0.35) + 1;
        const rX = c.r * spin;
        const rY = c.r;

        const coinGrad = ctx.createRadialGradient(c.x - 3, c.y - 4, 2, c.x, c.y, rY + 2);
        coinGrad.addColorStop(0, "#fff9d6");
        coinGrad.addColorStop(0.4, "#ffd447");
        coinGrad.addColorStop(1, "#c97a1a");
        ctx.fillStyle = coinGrad;
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, rX, rY, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.ellipse(c.x - 1, c.y - 3, rX / 2.3, rY / 2, 0, Math.PI * 1.2, Math.PI * 1.7);
        ctx.stroke();
      }
    }

    function drawParticles() {
      for (let p of particles) {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.c;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // meters display (moved lower so it doesn't overlap HUD)
    function drawMeters() {
      const metersNow = Math.floor(score / 2) * 100;
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.beginPath();
      ctx.roundRect(BASE_W/2 - 80, 50, 160, 34, 14);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "13px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(metersNow + " m", BASE_W/2, 72);
      ctx.textAlign = "left";
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.roundRect(10, 10, 150, 54, 10);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 26px system-ui, sans-serif";
      ctx.fillText(score.toString(), 20, 42);

      ctx.fillStyle = "#fff";
      ctx.font = "12px system-ui, sans-serif";
      ctx.fillText("Coins: " + totalCoins, 80, 28);
      ctx.fillText("Best: " + best, 80, 44);
    }

    function drawHomeScreen() {
      ctx.fillStyle = "rgba(2,6,23,0.35)";
      ctx.beginPath();
      ctx.roundRect(40, 110, BASE_W - 80, 290, 22);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 30px system-ui, sans-serif";
      ctx.fillText("FLAPPY+", 112, 150);
      ctx.font = "12px system-ui, sans-serif";
      ctx.fillText("coins: " + totalCoins, 115, 174);
      ctx.fillText("best: " + best, 115, 190);
      ctx.fillText("max m: " + maxMetersReached, 115, 206);

      // play button
      const pb = homeButtons.play;
      const pGrad = ctx.createLinearGradient(pb.x, pb.y, pb.x + pb.w, pb.y + pb.h);
      pGrad.addColorStop(0, "#38bdf8");
      pGrad.addColorStop(1, "#0ea5e9");
      ctx.fillStyle = pGrad;
      ctx.beginPath();
      ctx.roundRect(pb.x, pb.y, pb.w, pb.h, 16);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "15px system-ui, sans-serif";
      ctx.fillText("PLAY", pb.x + 68, pb.y + 30);

      // store button
      const sb = homeButtons.store;
      ctx.fillStyle = "rgba(15,23,42,0.55)";
      ctx.beginPath();
      ctx.roundRect(sb.x, sb.y, sb.w, sb.h, 14);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "12px system-ui, sans-serif";
      ctx.fillText("ðŸ›’ Store", sb.x + 14, sb.y + 24);

      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "11px system-ui, sans-serif";
      ctx.fillText("tap PLAY to start, or buy skins.", 66, 332);
    }

    function getStoreRects() {
      const rects = [];
      const startX = 36;
      const startY = 110;
      const w = 140;
      const h = 90;
      const padX = 16;
      const padY = 14;

      for (let i = 0; i < SKINS.length; i++) {
        const row = Math.floor(i / 2);
        const col = i % 2;
        rects.push({
          skin: SKINS[i],
          rect: {
            x: startX + col * (w + padX),
            y: startY + row * (h + padY),
            w: w,
            h: h
          }
        });
      }
      return rects;
    }

    function onStoreSelect(skin) {
      if (skin.unlockMeters && maxMetersReached < skin.unlockMeters) {
        return;
      }
      if (!ownedSkins[skin.id]) {
        if (totalCoins >= skin.price) {
          totalCoins -= skin.price;
          ownedSkins[skin.id] = true;
          activeSkin = skin.id;
          saveProgress();
        }
      } else {
        activeSkin = skin.id;
        saveProgress();
      }
    }

    function drawStore() {
      ctx.fillStyle = "rgba(15,23,42,0.6)";
      ctx.beginPath();
      ctx.roundRect(20, 55, BASE_W - 40, BASE_H - 110, 22);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 20px system-ui, sans-serif";
      ctx.fillText("STORE", 130, 82);

      ctx.font = "12px system-ui, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.fillText("Coins: " + totalCoins, 24, 100);
      ctx.fillText("Max meters: " + maxMetersReached, 170, 100);

      const storeRects = getStoreRects();
      for (let s of storeRects) {
        const { x, y, w, h } = s.rect;
        const skin = s.skin;
        const owned = !!ownedSkins[skin.id];
        const lockedByMeters = skin.unlockMeters && maxMetersReached < skin.unlockMeters;

        ctx.fillStyle = owned ? "rgba(148,163,184,0.2)" : "rgba(15,23,42,0.35)";
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, 14);
        ctx.fill();

        // preview
        ctx.save();
        ctx.translate(x + 30, y + 36);
        const prevSkin = activeSkin;
        activeSkin = skin.id;
        const oldBird = bird;
        bird = { x: 0, y: 0, anim: performance.now()*0.0001 };
        drawBird();
        bird = oldBird;
        activeSkin = prevSkin;
        ctx.restore();

        ctx.fillStyle = "#fff";
        ctx.font = "13px system-ui, sans-serif";
        ctx.fillText(skin.name, x + 60, y + 26);

        ctx.font = "11px system-ui, sans-serif";
        if (skin.id === "plane") {
          ctx.fillStyle = lockedByMeters ? "rgba(248,113,113,0.9)" : "rgba(190,242,100,0.9)";
          ctx.fillText("Unlock: " + skin.unlockMeters + "m", x + 60, y + 44);
        } else if (skin.price > 0) {
          ctx.fillStyle = owned ? "rgba(190,242,100,0.9)" : "rgba(248,250,252,0.8)";
          ctx.fillText("Price: " + skin.price + " coins", x + 60, y + 44);
        } else {
          ctx.fillStyle = "rgba(190,242,100,0.9)";
          ctx.fillText("Free", x + 60, y + 44);
        }

        ctx.fillStyle = owned ? "rgba(34,197,94,1)" : (lockedByMeters ? "rgba(248,113,113,0.9)" : "rgba(59,130,246,0.9)");
        ctx.beginPath();
        ctx.roundRect(x + 60, y + 56, 60, 20, 8);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.font = "10px system-ui, sans-serif";
        ctx.fillText(owned ? "Use" : (lockedByMeters ? "Locked" : "Buy"), x + 74, y + 70);
      }

      ctx.fillStyle = "rgba(255,255,255,0.45)";
      ctx.font = "11px system-ui, sans-serif";
      ctx.fillText("ESC to go back", 32, BASE_H - 30);
    }

    function drawGameOver() {
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(0, 0, BASE_W, BASE_H);

      const cardW = 260, cardH = 200;
      const cx = (BASE_W - cardW)/2;
      const cy = (BASE_H - cardH)/2;
      ctx.fillStyle = "rgba(255,255,255,0.98)";
      ctx.beginPath();
      ctx.roundRect(cx, cy, cardW, cardH, 16);
      ctx.fill();

      ctx.fillStyle = "#0f172a";
      ctx.font = "bold 26px system-ui, sans-serif";
      ctx.fillText("GAME OVER", cx + 42, cy + 42);

      ctx.fillStyle = "#334155";
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText("Score: " + score, cx + 30, cy + 78);
      ctx.fillText("Best: " + best, cx + 30, cy + 100);
      ctx.fillText("Coins: " + totalCoins, cx + 30, cy + 122);
      ctx.fillText("Max m: " + maxMetersReached, cx + 30, cy + 144);

      const bw = cardW - 50, bh = 44;
      const bx = cx + 25, by = cy + 134;
      const btnGrad = ctx.createLinearGradient(bx, by, bx + bw, by + bh);
      btnGrad.addColorStop(0, "#38bdf8");
      btnGrad.addColorStop(1, "#0ea5e9");
      ctx.fillStyle = btnGrad;
      ctx.beginPath();
      ctx.roundRect(bx, by, bw, bh, 12);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText("tap to restart", bx + 58, by + 27);
    }

    let last = performance.now();
    function loop(now) {
      const dt = now - last;
      last = now;
      update(dt, now);

      ctx.clearRect(0, 0, BASE_W, BASE_H);
      drawBackground();
      drawPipes();
      drawGround();
      drawCoins();
      drawParticles();
      drawBird();

      if (gameState === "home") {
        drawHomeScreen();
        drawMeters();
      } else if (gameState === "playing") {
        drawHUD();
        drawMeters();
      } else if (gameState === "paused") {
        drawHUD();
        drawMeters();
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(0, 0, BASE_W, BASE_H);
        ctx.fillStyle = "#fff";
        ctx.font = "bold 32px system-ui, sans-serif";
        ctx.fillText("PAUSED", 108, BASE_H/2);
      } else if (gameState === "gameover") {
        drawHUD();
        drawMeters();
        drawGameOver();
      } else if (gameState === "store") {
        drawStore();
        drawMeters();
      }

      requestAnimationFrame(loop);
    }

    resetGame(true);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
